from calc.calculate_phase_base import CalculatePhaseBase, BY_CONFIGURATION, BY_MIN_DELEGATION
from model.baking_conf import MIN_DELEGATION_KEY
from model.reward_log import RewardLog
from util.rounding_command import RoundingCommand


class CalculatePhase1(CalculatePhaseBase):
    """
    -- Phase1 : Total Rewards Phase --

    At phase 1, share of the excluded delegators remains in the staking Balance. Remaining rewards are distributed among other delegators.
    """

    def __init__(self, excluded_set, min_delegation_amount=None, prcnt_rm=RoundingCommand(None)) -> None:
        """
        :param excluded_set: set of address to exclude from rewards. Excluded rewards will leave at staking balance. Total reward will be updated.
        :param prcnt_rm: RoundingCommand object for percentage calculations. Since this is the first layer in calculations RoundingCommand(None) is recommended to avoid rounding.
        """
        super().__init__()

        self.min_delegation_amount = min_delegation_amount
        self.prcnt_rm = prcnt_rm
        self.excluded_set = excluded_set
        self.phase = 1

    def calculate(self, reward_data0, total_amount):
        """
        :param reward_data0: reward data from phase 0
        :param total_amount: total amount of rewards.
        :return: tuple (reward_data1,updated_total_amnt)
        reward_data1 is generated by excluding requested addresses. Remaining ratios are adjusted.
        updated_total_amnt is new reward amount where share of excluded addresses are subtracted.
        """

        # rewards, total_amount = self.old_method(reward_data0, total_amount)
        rewards = []
        total_balance_excluded = 0
        total_balance = 0

        # exclude requested addresses from reward list
        for rl0 in reward_data0:
            total_balance += rl0.balance
            if rl0.address in self.excluded_set:
                rl0.skip(desc=BY_CONFIGURATION, phase=self.phase)
                rewards.append(rl0)
                total_balance_excluded += rl0.balance
            elif MIN_DELEGATION_KEY in self.excluded_set and rl0.balance < self.min_delegation_amount:
                rl0.skip(desc=BY_MIN_DELEGATION, phase=self.phase)
                rewards.append(rl0)
                total_balance_excluded += rl0.balance
            else:
                # ratio will be replaced with actual ratio, read below
                rewards.append(rl0)

        new_total_balance = total_balance - total_balance_excluded

        # calculate new ratio using remaining balance
        for rl1 in self.filterskipped(rewards):
            rl1.ratio = self.prcnt_rm.round(rl1.balance / new_total_balance)
            rl1.ratio1 = rl1.ratio

        # total reward amount needs to be diminished at the same rate total balance diminishes
        new_total_amnt_multiplier = new_total_balance / total_balance
        new_total_amount = int(total_amount * new_total_amnt_multiplier)

        return rewards, new_total_amount
