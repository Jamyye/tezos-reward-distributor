from calc.calculate_phase_base import CalculatePhaseBase, BY_CONFIGURATION, BY_MIN_DELEGATION
from model.reward_log import RewardLog
from util.rounding_command import RoundingCommand


class CalculatePhase1(CalculatePhaseBase):
    """
    At phase 1, share of the excluded delegators remains in the staking balance. Remaining rewards are distributed among other delegators.
    """

    def __init__(self, excluded_set, min_delegation_amount=None, prcnt_rm=RoundingCommand(None)) -> None:
        """
        :param excluded_set: set of address to exclude from rewards. Excluded rewards will leave at staking balance. Total reward will be updated.
        :param prcnt_rm: RoundingCommand object for percentage calculations. Since this is the first layer in calculations RoundingCommand(None) is recommended to avoid rounding.
        """
        super().__init__()

        self.min_delegation_amount = min_delegation_amount
        self.prcnt_rm = prcnt_rm
        self.excluded_set = excluded_set
        self.phase = 1

    def calculate(self, reward_data0, total_amount):
        """
        :param reward_data0: reward data from phase 0
        :param total_amount: total amount of rewards.
        :return: tuple (reward_data1,updated_total_amnt)
        reward_data1 is generated by excluding requested addresses. Remaining ratios are adjusted.
        updated_total_amnt is new reward amount where share of excluded addresses are subtracted.
        """

        # rewards, total_amount = self.old_method(reward_data0, total_amount)
        rewards = []
        total_balance_excluded = 0
        total_balance = 0

        # exclude requested addresses from reward list
        for rl0 in reward_data0:
            total_balance += rl0.balance
            if rl0.address in self.excluded_set:
                rl0.skip(desc=BY_CONFIGURATION, phase=self.phase)
                rewards.append(rl0)
                total_balance_excluded += rl0.balance
            elif self.min_delegation_amount is not None and rl0.balance < self.min_delegation_amount:
                rl0.skip(desc=BY_MIN_DELEGATION, phase=self.phase)
                rewards.append(rl0)
                total_balance_excluded += rl0.balance
            else:
                # ratio will be replaced with actual ratio, read below
                rewards.append(rl0)

        new_total_balance = total_balance - total_balance_excluded

        # calculate new ratio using remaining balance
        for rl1 in self.filterskipped(rewards):
            rl1.ratio1 = self.prcnt_rm.round(rl1.balance / new_total_balance)

        # total reward amount needs to be diminished at the same rate total balance diminishes
        new_total_amnt_multiplier = new_total_balance / total_balance

        return rewards, total_amount * new_total_amnt_multiplier

    def old_method(self, reward_data0, total_amount):
        rewards = []
        total_excluded_ratio = 0.0

        # calculate how rewards will be distributed
        for rl0 in reward_data0:
            if rl0.address in self.excluded_set:
                total_excluded_ratio += rl0.ratio
            else:
                rewards.append(RewardLog(rl0, rl0.ratio))  # not upto date anymore
        # We need to distribute excluded ratios among remaining records
        # a,b,c,d -> b*(1+(a/1-a)), c*(1+(a/1-a)), d*(1+ (a/1-a)) -> (1+(a/1-a))*(b,c,d)
        # calculate 1+(a/1-a)
        multiplier = 1 + total_excluded_ratio / (1 - total_excluded_ratio)
        # for each record, calculate new ratio
        for pr in rewards:
            pr.ratio = self.prcnt_rm.round(pr.ratio * multiplier)
        # subtract from total amount, subtracted amount will remain in staking balance
        total_amount = total_amount * (1 - total_excluded_ratio)
        return total_amount
